{"version":3,"sources":["dbhelper.js","app.js"],"names":["offlineMessage","document","getElementById","noDataMessage","dataSavedMessage","saveErrorMessage","DBHelper","id","1","2","3","4","5","6","7","8","9","10","lastUpdated","this","getLastUpdated","textContent","style","display","localStorage","getItem","date","setItem","result","console","log","error","response","ok","Error","statusText","json","pathToResource","fetch","then","validateResponse","readResponseAsJSON","restaurant","imageType","width","fileExtension","map","google","maps","Marker","position","latlng","title","name","url","getRestaurantURL","animation","Animation","DROP","neighborhoods","cuisines","restaurants","markers","endpointRestaurants","elementGoogleMap","elementNeighborhoodsSelect","elementCuisinesSelect","elementRestaurantsList","addEventListener","event","loadMainNetworkFirst","getServerData","dataFromNetwork","updateNeighborhoodsUI","updateCuisinesUI","saveRestaurantsDataLocally","setLastUpdated","Date","catch","err","warn","getLocalRestaurantsData","offlineData","length","allNeighborhoods","v","i","neighborhood","self","filter","indexOf","forEach","option","createElement","innerHTML","value","appendChild","allCuisines","cuisine_type","cuisine","refreshRestaurantsNetworkFirst","refreshRestaurantsUI","neighborhoodIndex","selectedIndex","cuisineIndex","m","setMap","r","addRestaurantCardUI","addMarkersToMapUI","li","className","createResponsivePicture","divCardPrimary","divCardSecondary","address","divCardActions","more","href","picture","sizes","srcsetWebP","getImageUrlForRestaurant","srcsetJPEG","sourceWebP","srcset","type","sourceDefault","defaultImg","imageSrc","src","altText","getAlternativeText","alt","window","initMap","Map","center","lat","lng","zoom","addListener","querySelector","setAttribute","arguments","undefined","marker","addMarkerForRestaurant","location","push"],"mappings":"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","file":"main-bundle.min.js","sourcesContent":["const offlineMessage = document.getElementById('offline');\r\nconst noDataMessage = document.getElementById('no-data');\r\nconst dataSavedMessage = document.getElementById('data-saved');\r\nconst saveErrorMessage = document.getElementById('save-error');\r\n\r\n\r\n/**\r\n * DBHelper provides functions to interact with the local development API server\r\n * provided by Udacity for project 2.\r\n * https://github.com/udacity/mws-restaurant-stage-2\r\n * curl \"http://localhost:1337/restaurants\"\r\n * curl \"http://localhost:1337/restaurants/{3}\"\r\n */\r\n\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Alternative Text as the API server doesn't provide it.\r\n   */\r\n  static getAlternativeText(id) {\r\n    const altTexts = {\r\n      1: \"Interior of Mission Chinese Food\",\r\n      2: \"Pizza Quattro Formaggi\",\r\n      3: \"Interior of Kang Ho Dong Baekjeong\",\r\n      4: \"Outside view of Katz's Delicatessen at night\",\r\n      5: \"Open kitchen of Roberta's Pizza\",\r\n      6: \"People queueing at Hometown BBQ\",\r\n      7: \"Outside view of Superiority Burger\",\r\n      8: \"Outside view of The Dutch\",\r\n      9: \"People eating at Mu Ramen\",\r\n      10: \"Interior of Casa Enrique\"\r\n    };\r\n    return altTexts[id];\r\n  }\r\n\r\n  // Alert user that data may not be current\r\n  // \"You're offline and viewing stored data.\"\r\n  static messageOffline() {\r\n    const lastUpdated = this.getLastUpdated();\r\n    if (lastUpdated) {\r\n     offlineMessage.textContent += ' Last fetched server data: ' + lastUpdated;\r\n    }\r\n    offlineMessage.style.display = 'block';\r\n  }\r\n\r\n  // Alert user that there is no data available.\r\n  // \"You're offline and local data is unavailable.\"\r\n  static messageNoData() {\r\n    //\r\n    noDataMessage.style.display = 'block';\r\n  }\r\n\r\n  // Alert user that data has been saved for offline.\r\n  // \"Server data was saved for offline mode.\"\"\r\n  static messageDataSaved() {\r\n    const lastUpdated = this.getLastUpdated();\r\n    if (lastUpdated) {dataSavedMessage.textContent += ' on ' + lastUpdated;}\r\n    dataSavedMessage.style.display = 'block';\r\n  }\r\n\r\n  // Alert user that data couldn't be saved offline\r\n  // \"Server data couldn't be saved offline.\"\"\r\n  static messageSaveError() {\r\n    saveErrorMessage.style.display = 'block';\r\n  }\r\n\r\n  // Util network function.\r\n  static getLastUpdated() {\r\n    return localStorage.getItem('lastUpdated');\r\n  }\r\n\r\n  // Util network function.\r\n  static setLastUpdated(date) {\r\n    localStorage.setItem('lastUpdated', date);\r\n  }\r\n\r\n  /*\r\n   * logResult is available for debugging puprposes, it does some logging\r\n   * of the JSON data.\r\n   */\r\n  static logResult(result) {\r\n    console.log(result);\r\n  }\r\n\r\n  /*\r\n   * The fetch call returns a promise that resolves to a response object.\r\n   * If the request does not complete, .catch takes over and is passed the\r\n   * corresponding error.\r\n   */\r\n  static logError(error) {\r\n    console.log('[ERROR] Looks like there was a problem: \\n', error);\r\n  }\r\n\r\n  /*\r\n   * validateResponse checks if the response is valid (is it a 200-299?).\r\n   * If it isn't, an error is thrown, skipping the rest of the then blocks and\r\n   * triggering the catch block. Without this check bad responses are passed\r\n   * down the chain and could break later code that may rely on receiving\r\n   * a valid response. If the response is valid, it is passed to\r\n   * readResponseAsJSON.\r\n   * TODO: respond with custom pages for different errors or handle other\r\n   * responses that are not ok (i.e., not 200-299), but still usable\r\n   * (e.g., status codes in the 300 range)\r\n   */\r\n  static validateResponse(response) {\r\n    if (!response.ok) {\r\n      throw Error(response.statusText);\r\n    }\r\n    return response;\r\n  }\r\n\r\n  /*\r\n   * readResponseAsJSON reads the body of the response using the Response.json()\r\n   * method. This method returns a promise that resolves to JSON. Once this\r\n   * promise resolves, the JSON data is passed to logResult.\r\n   */\r\n  static readResponseAsJSON(response) {\r\n    return response.json();\r\n  }\r\n\r\n  /**\r\n   * Get the database URL.\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337;\r\n    return `http://localhost:${port}`;\r\n  }\r\n\r\n  /**\r\n   * getServerData\r\n   */\r\n  static getServerData(pathToResource) {\r\n    // Fetch is called on a resource and Fetch returns a promise that will\r\n    // resolve to a response object. When the promise resolves, the response\r\n    // object is passed to validateResponse.\r\n    return fetch(pathToResource)\r\n      .then(this.validateResponse)\r\n      .then(this.readResponseAsJSON)\r\n      // Once the promise resolves, the JSON data is passed to logResult.\r\n      // .then(this.logResult)\r\n      // .catch(this.logError);\r\n  }\r\n\r\n  /**\r\n   * Returns the relative url for a restaurant.\r\n   */\r\n  static getRestaurantURL(restaurant) {\r\n    // return `./restaurant.html?id=${restaurant.id}`\r\n    return `restaurant.html?id=${restaurant.id}`\r\n  }\r\n\r\n  /**\r\n   * Returns the restaurant image URL.\r\n   * Using id to construct urls as the local development API server doesn't\r\n   * always have a photograph field.\r\n   * jpg is default image type.\r\n   * 800 is default width.\r\n   */\r\n  static getImageUrlForRestaurant(restaurant, imageType, width) {\r\n    // Default image type is jpeg.\r\n    let fileExtension = 'jpg';\r\n    switch (imageType) {\r\n      case 'jpeg':\r\n        break;\r\n      case 'webp':\r\n        fileExtension = 'webp';\r\n        break;\r\n      default:\r\n        console.log(`[DEBUG] unhandled imageType: ${imageType}`);\r\n    }\r\n    if (typeof width !== 'undefined') {\r\n      return `img/${restaurant.id}_w_${width}.${fileExtension}`;\r\n    } else {\r\n      return `img/${restaurant.id}_w_800.${fileExtension}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a Google Maps marker for a restaurant.\r\n   */\r\n  static addMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.getRestaurantURL(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n}\r\n","/**\r\n * TODO: Add to Home Screen (aka Web App Install Banners)\r\n * trigger the Add to Home Screen prompt by using the beforeinstallprompt event.\r\n * https://developers.google.com/web/fundamentals/app-install-banners/\r\n */\r\n\r\n// Declare global variables.\r\nlet map;\r\nlet neighborhoods;\r\nlet cuisines;\r\nlet restaurants;\r\nlet markers = [];\r\nconst endpointRestaurants = `http://localhost:1337/restaurants`;\r\n\r\n// Declare the id elements.\r\nconst elementGoogleMap = document.getElementById('map');\r\nconst elementNeighborhoodsSelect = document.getElementById('neighborhoods-select');\r\nconst elementCuisinesSelect = document.getElementById('cuisines-select');\r\nconst elementRestaurantsList = document.getElementById('restaurants-list');\r\n\r\n\r\n/**\r\n * Start the following when the initial HTML document has been\r\n * completely loaded and parsed, without waiting for stylesheets, images,\r\n * and subframes to finish loading.\r\n * Fetch neighborhoods and cuisines.\r\n * https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n  loadMainNetworkFirst();\r\n});\r\n\r\n/**\r\n * Fetch all neighborhoods and cuisines from network and fallback to IndexedDB,\r\n * update UI.\r\n * In loadMainNetworkFirst, once the server data is received, IndexedDB and\r\n * the page are updated. Then, when the data is successfully saved, a timestamp\r\n * is stored and the user is notified that the data is available for\r\n * offline use. If there is no network availability when this function is\r\n * called, then the getServerData function rejects and the catch method takes\r\n * over. In the catch call, the getLocalRestaurantsData function retrieves\r\n * local data from IndexedDB. If there isn't any local data saved, then\r\n * the user is alerted by messageNoData. Otherwise the local data is displayed\r\n * and a message informs the user that the data might be outdated.\r\n */\r\nconst loadMainNetworkFirst = () => {\r\n  DBHelper.getServerData(endpointRestaurants)\r\n  .then(dataFromNetwork => {\r\n    updateNeighborhoodsUI(dataFromNetwork);\r\n    updateCuisinesUI(dataFromNetwork);\r\n    saveRestaurantsDataLocally(dataFromNetwork)\r\n    .then(() => {\r\n      DBHelper.setLastUpdated(new Date());\r\n      // DBHelper.messageDataSaved();\r\n    }).catch(err => {\r\n      // DBHelper.messageSaveError();\r\n      console.warn(err);\r\n    });\r\n  }).catch(err => {\r\n    console.log('[DEBUG] Network requests have failed, this is expected if offline');\r\n    getLocalRestaurantsData()\r\n    .then(offlineData => {\r\n      if (!offlineData.length) {\r\n        // DBHelper.messageNoData();\r\n      } else {\r\n        // DBHelper.messageOffline();\r\n        updateNeighborhoodsUI(offlineData);\r\n        updateCuisinesUI(offlineData);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Update UI of Neighborhoods select element.\r\n */\r\nconst updateNeighborhoodsUI = (result) => {\r\n  // Get all neighborhoods from all restaurants.\r\n  let allNeighborhoods = result.map((v, i) => result[i].neighborhood);\r\n  // Remove duplicates from neighborhoods and assign to global variable.\r\n  self.neighborhoods = allNeighborhoods.filter((v, i) => allNeighborhoods.indexOf(v) == i);\r\n  // Update the neighborhoods select.\r\n  neighborhoods.forEach(neighborhood => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = neighborhood;\r\n    option.value = neighborhood;\r\n    elementNeighborhoodsSelect.appendChild(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Update UI of Cuisines select element.\r\n */\r\nconst updateCuisinesUI = (result) => {\r\n  // Get all cuisines from all restaurants.\r\n  let allCuisines = result.map((v, i) => result[i].cuisine_type);\r\n  // Remove duplicates from cuisines and assign to global variable.\r\n  self.cuisines = allCuisines.filter((v, i) => allCuisines.indexOf(v) == i);\r\n  // Update the cuisines select.\r\n  cuisines.forEach(cuisine => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = cuisine;\r\n    option.value = cuisine;\r\n    elementCuisinesSelect.appendChild(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch all restaurants from network and fallback to IndexedDB, update UI.\r\n */\r\nconst refreshRestaurantsNetworkFirst = () => {\r\n  DBHelper.getServerData(endpointRestaurants)\r\n  .then(dataFromNetwork => {\r\n    refreshRestaurantsUI(dataFromNetwork);\r\n    saveRestaurantsDataLocally(dataFromNetwork)\r\n    .then(() => {\r\n      DBHelper.setLastUpdated(new Date());\r\n      // DBHelper.messageDataSaved();\r\n    }).catch(err => {\r\n      // DBHelper.messageSaveError();\r\n      console.warn(err);\r\n    });\r\n  }).catch(err => {\r\n    console.log('[DEBUG] Network requests have failed, this is expected if offline');\r\n    getLocalRestaurantsData()\r\n    .then(offlineData => {\r\n      if (!offlineData.length) {\r\n        // DBHelper.messageNoData();\r\n      } else {\r\n        // DBHelper.messageOffline();\r\n        refreshRestaurantsUI(offlineData);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Update ul restaurants-list and markers on map for current restaurants.\r\n */\r\nconst refreshRestaurantsUI = (result) => {\r\n  // Retrieve the selected neighborhood and cuisine.\r\n  const neighborhoodIndex = elementNeighborhoodsSelect.selectedIndex;\r\n  const cuisineIndex = elementCuisinesSelect.selectedIndex;\r\n  const neighborhood = elementNeighborhoodsSelect[neighborhoodIndex].value;\r\n  const cuisine = elementCuisinesSelect[cuisineIndex].value;\r\n\r\n  // Clear ul restaurants-list and markers on map for current restaurants.\r\n  self.restaurants = [];\r\n  elementRestaurantsList.innerHTML = '';\r\n  markers.forEach(m => m.setMap(null));\r\n  markers = [];\r\n\r\n  // Filter the data by neighborhood and cuisine.\r\n  self.restaurants = result;\r\n  if (neighborhood != 'all') {\r\n    self.restaurants = self.restaurants.filter(r => r.neighborhood == neighborhood);\r\n  }\r\n  if (cuisine != 'all') {\r\n    self.restaurants = self.restaurants.filter(r => r.cuisine_type == cuisine);\r\n  }\r\n\r\n  // Create ul restaurants-list and add markers on map for current restaurants.\r\n  self.restaurants.forEach(restaurant => {\r\n    elementRestaurantsList.appendChild(addRestaurantCardUI(restaurant));\r\n  });\r\n  addMarkersToMapUI();\r\n}\r\n\r\n/**\r\n * Create a restaurant card in a li element.\r\n */\r\nconst addRestaurantCardUI = (restaurant) => {\r\n  const li = document.createElement('li');\r\n  li.className = 'restaurant-card';\r\n\r\n  li.appendChild(createResponsivePicture(restaurant));\r\n\r\n  // Create a div with class card-primary that contains h2, h3.\r\n  const divCardPrimary = document.createElement('div');\r\n  divCardPrimary.className = 'card-primary';\r\n  const name = document.createElement('h2');\r\n  name.className = 'card-title';\r\n  name.innerHTML = restaurant.name;\r\n  divCardPrimary.appendChild(name);\r\n  const neighborhood = document.createElement('h3');\r\n  neighborhood.className = 'card-subtitle';\r\n  neighborhood.innerHTML = restaurant.neighborhood;\r\n  divCardPrimary.appendChild(neighborhood);\r\n  li.appendChild(divCardPrimary);\r\n\r\n  // Create a div with class card-secondary that contains further content.\r\n  const divCardSecondary = document.createElement('div');\r\n  divCardSecondary.className = 'card-secondary';\r\n  // Use contact address element.\r\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address\r\n  const address = document.createElement('address');\r\n  address.className = 'card-secondary-content';\r\n  address.innerHTML = restaurant.address;\r\n  divCardSecondary.appendChild(address);\r\n  li.appendChild(divCardSecondary);\r\n\r\n  // Create a div with class card-actions.\r\n  const divCardActions = document.createElement('div');\r\n  divCardActions.className = 'card-actions';\r\n  const more = document.createElement('a');\r\n  more.className = 'card-actions-link';\r\n  more.innerHTML = 'View Details';\r\n  more.href = DBHelper.getRestaurantURL(restaurant);\r\n  divCardActions.appendChild(more);\r\n  li.appendChild(divCardActions);\r\n\r\n  return li;\r\n}\r\n\r\n/**\r\n * Create a responsive image.\r\n *\r\n * Main page\r\n * 0 to 479px: card has width 100%, so 1 img 100% (455 x 321).\r\n * 480 to 599px: card has width 100%, so 1 img fullwidth (567 x 425).\r\n * 600 to 839px: card has width 45%, so 2 img 45% (378 x 283).\r\n * 840 to 959px: card has width 45%, so 2 img 45% (432 x 324).\r\n * 960 to 1279px: card has width 30%, so 3 img 30% (384 x 289).\r\n * 1280px to x: card has width 22.5%, so 4 img 22.5% (minimum 288 x 216).\r\n *\r\n * Restaurant Info\r\n * 0 to 479px: card has width 100%, so 1 img 100% (479 x 359).\r\n * 480 to 599px: card has width 100%, so 1 img fullwidth (599 x 449).\r\n * 600 to 839px: card has width 50%, so 1 img 50% (419.5 x 315).\r\n * 840 to 959px: card has width 50%, so 1 img 50% (479.5 x 360).\r\n * 960 to 1279px: card has width 50%, so 1 img 50% (639.5 x 480).\r\n * 1280px to x: card has width 50%, so 1 img 50% (minimum 640 x 480).\r\n *\r\n * Image breakpoints have been determined using the Cloudinary generator.\r\n * http://www.responsivebreakpoints.com/\r\n * Image widths are 300, 433, 552, 653, 752, 800\r\n *\r\n * The srcset attribute gives the browser the option to choose which file\r\n * to use. However, the browser has no way of determining the file sizes before\r\n * it loads them, so it always chooses the first image in the list.\r\n *\r\n * To load the correct image size based on the viewport width we need to tell\r\n * the browser how big each file is before it fetches them.\r\n * By adding a width descriptor to each file in the srcset, we are telling\r\n * the browser the width of each image in pixels before it fetches the image.\r\n * The browser can then use these widths to decide which image to fetch based\r\n * on its window size. It fetches the image with the smallest width that is\r\n * still larger than the viewport width.\r\n *\r\n * Because the CSS is parsed after the HTML at runtime, the browser has no way\r\n * to know what the final display size of the image will be when it fetches it.\r\n * Unless we tell it otherwise, the browser assumes the images will be displayed\r\n * at 100% of the viewport width and fetches the images based on this.\r\n *\r\n * The sizes value matches the image's max-width value in the CSS. The browser\r\n * now has everything it needs to choose the correct image version. The browser\r\n * knows its own viewport width and the pixel density of the user's device,\r\n * and we have given it the source files' dimensions (using width descriptor)\r\n * and the image sizes relative to the viewport (the sizes attribute).\r\n *\r\n * The media query tests the viewport width of the screen, and applies the CSS.\r\n * We can tell the browser about the media query in the sizes attribute so that\r\n * it fetches the correct image when the image changes size.\r\n *\r\n * We can use the <picture> element and the <source> element, in combination\r\n * with media queries, to change the image source as the window is resized.\r\n *\r\n * The <picture> element lets us define multiple source files using the\r\n * <source> tag. This is different than simply using an <img> tag with the\r\n * srcset attribute because the source tag lets us add things like media queries\r\n * to each set of sources. Instead of giving the browser the image sizes and\r\n * letting it decide which files to use, we can define the images to use at\r\n * each window size.\r\n *\r\n * If the user's browser doesn't support the <picture> element, it fetches\r\n * whatever is in the <img> element. The <picture> element is just used to\r\n * specify multiple sources for the <img> element contained in it. The <img>\r\n * element is what displays the image.\r\n *\r\n * Display density descriptors are great for fixed width images, but are\r\n * insufficient for flexible images.\r\n */\r\nconst createResponsivePicture = (restaurant) => {\r\n  const picture = document.createElement('picture');\r\n\r\n  // sizes: the browser ignores everything after the first matching condition.\r\n  const sizes = '(min-width: 80rem) 22.5vw, (min-width: 60rem) 30vw, (min-width: 37.5rem) 45vw, 100vw';\r\n\r\n  // srcset\r\n  const srcsetWebP =\r\n    `${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 300)} 300w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 433)} 433w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 552)} 552w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 653)} 653w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 752)} 752w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 800)} 800w`;\r\n\r\n  const srcsetJPEG =\r\n    `${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 300)} 300w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 433)} 433w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 552)} 552w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 653)} 653w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 752)} 752w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 800)} 800w`;\r\n\r\n  const sourceWebP = document.createElement('source');\r\n  sourceWebP.srcset = srcsetWebP;\r\n  sourceWebP.sizes = sizes;\r\n  sourceWebP.type = 'image/webp';\r\n  picture.appendChild(sourceWebP);\r\n\r\n  const sourceDefault = document.createElement('source');\r\n  sourceDefault.srcset = srcsetJPEG;\r\n  sourceDefault.sizes = sizes;\r\n  sourceDefault.type = 'image/jpeg';\r\n  picture.appendChild(sourceDefault);\r\n\r\n  const defaultImg = document.createElement('img');\r\n  // Get default image which should be width 800.\r\n  const imageSrc = DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 800);\r\n  defaultImg.src = imageSrc;\r\n\r\n  let altText = DBHelper.getAlternativeText(restaurant.id);\r\n  if (!altText) {\r\n    altText = `Restaurant ${restaurant.name}`;\r\n  }\r\n  defaultImg.alt = altText;\r\n  picture.appendChild(defaultImg);\r\n\r\n  return picture;\r\n}\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n * https://developers.google.com/maps/documentation/javascript/tutorial\r\n * https://developers.google.com/maps/documentation/javascript/tutorial#Loading_the_Maps_API\r\n */\r\nwindow.initMap = () => {\r\n  let loc = {lat: 40.722216, lng: -73.987501};\r\n  // Not using scrollwheel: False anymore, using default gestureHandling: auto\r\n  // https://developers.google.com/maps/documentation/javascript/interaction\r\n  // self.map = new google.maps.Map(elementGoogleMap, {\r\n  map = new google.maps.Map(elementGoogleMap, {\r\n    center: loc,\r\n    zoom: 12\r\n  });\r\n  // a11y - Frames must have non-empty title attribute\r\n  // https://dequeuniversity.com/rules/axe/2.2/frame-title\r\n  // https://developers.google.com/maps/documentation/javascript/events\r\n  let setTitle = () => {\r\n    const iFrameGoogleMaps = document.querySelector('#map iframe');\r\n    iFrameGoogleMaps.setAttribute('title', 'Google Maps overview of restaurants');\r\n  }\r\n  // self.map.addListener('tilesloaded', setTitle);\r\n  map.addListener('tilesloaded', setTitle);\r\n  // Refresh all restaurants.\r\n  refreshRestaurantsNetworkFirst();\r\n}\r\n\r\n/**\r\n * Add markers for current restaurants to the map.\r\n */\r\nconst addMarkersToMapUI = (restaurants = self.restaurants) => {\r\n  restaurants.forEach(restaurant => {\r\n    const marker = DBHelper.addMarkerForRestaurant(restaurant, self.map);\r\n    google.maps.event.addListener(marker, 'click', () => {\r\n      window.location.href = marker.url\r\n    });\r\n    markers.push(marker);\r\n  });\r\n}\r\n"],"sourceRoot":"/source/"}